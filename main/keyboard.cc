#include "keyboard.h"

#include <array>
#include <cstdint>
#include <cstring>
#include <utility>

#define LOG_LOCAL_LEVEL ESP_LOG_VERBOSE
#include <class/hid/hid.h>
#include <esp_err.h>
#include <esp_log.h>
#include <esp_task_wdt.h>
#include <i2clib/address.h>
#include <i2clib/master.h>
#include <i2clib/operation.h>
#include <kbdlib/adp5589.h>

#include "gpio_pins.h"
#include "usb_hid.h"

using kbd::adp5589::CoreFrequency;
using kbd::adp5589::EventID;
using kbd::adp5589::RegNum;

namespace {
constexpr char TAG[] = "Keyboard";
constexpr uint8_t kSlaveAddress = 0x34;  // I2C address of ADP5589 IC.
constexpr i2c::Address::Size kI2CAddressSize = i2c::Address::Size::bit7;
// Table generated by genmap.py.
constexpr std::array<uint8_t, 128> kEventID2KeyCode = {
    HID_KEY_NONE,          // 0: NONE
    HID_KEY_E,             // 1: R0_C0
    HID_KEY_W,             // 2: R0_C1
    HID_KEY_Q,             // 3: R0_C2
    HID_KEY_SHIFT_LEFT,    // 4: R0_C3
    HID_KEY_NONE,          // 5: R0_C4
    HID_KEY_NONE,          // 6: R0_C5
    HID_KEY_NONE,          // 7: R0_C6
    HID_KEY_NONE,          // 8: R0_C7
    HID_KEY_NONE,          // 9: R0_C8
    HID_KEY_NONE,          // 10: R0_C9
    HID_KEY_NONE,          // 11: R0_C10
    HID_KEY_NONE,          // 12: R1_C0
    HID_KEY_S,             // 13: R1_C1
    HID_KEY_A,             // 14: R1_C2
    HID_KEY_CONTROL_LEFT,  // 15: R1_C3
    HID_KEY_NONE,          // 16: R1_C4
    HID_KEY_NONE,          // 17: R1_C5
    HID_KEY_NONE,          // 18: R1_C6
    HID_KEY_NONE,          // 19: R1_C7
    HID_KEY_NONE,          // 20: R1_C8
    HID_KEY_NONE,          // 21: R1_C9
    HID_KEY_NONE,          // 22: R1_C10
    HID_KEY_NONE,          // 23: R2_C0
    HID_KEY_NONE,          // 24: R2_C1
    HID_KEY_NONE,          // 25: R2_C2
    HID_KEY_NONE,          // 26: R2_C3
    HID_KEY_NONE,          // 27: R2_C4
    HID_KEY_NONE,          // 28: R2_C5
    HID_KEY_NONE,          // 29: R2_C6
    HID_KEY_NONE,          // 30: R2_C7
    HID_KEY_NONE,          // 31: R2_C8
    HID_KEY_NONE,          // 32: R2_C9
    HID_KEY_NONE,          // 33: R2_C10
    HID_KEY_NONE,          // 34: R3_C0
    HID_KEY_NONE,          // 35: R3_C1
    HID_KEY_NONE,          // 36: R3_C2
    HID_KEY_NONE,          // 37: R3_C3
    HID_KEY_NONE,          // 38: R3_C4
    HID_KEY_NONE,          // 39: R3_C5
    HID_KEY_NONE,          // 40: R3_C6
    HID_KEY_NONE,          // 41: R3_C7
    HID_KEY_NONE,          // 42: R3_C8
    HID_KEY_NONE,          // 43: R3_C9
    HID_KEY_NONE,          // 44: R3_C10
    HID_KEY_NONE,          // 45: R4_C0
    HID_KEY_NONE,          // 46: R4_C1
    HID_KEY_NONE,          // 47: R4_C2
    HID_KEY_NONE,          // 48: R4_C3
    HID_KEY_NONE,          // 49: R4_C4
    HID_KEY_NONE,          // 50: R4_C5
    HID_KEY_NONE,          // 51: R4_C6
    HID_KEY_NONE,          // 52: R4_C7
    HID_KEY_NONE,          // 53: R4_C8
    HID_KEY_NONE,          // 54: R4_C9
    HID_KEY_NONE,          // 55: R4_C10
    HID_KEY_NONE,          // 56: R5_C0
    HID_KEY_NONE,          // 57: R5_C1
    HID_KEY_NONE,          // 58: R5_C2
    HID_KEY_NONE,          // 59: R5_C3
    HID_KEY_NONE,          // 60: R5_C4
    HID_KEY_NONE,          // 61: R5_C5
    HID_KEY_NONE,          // 62: R5_C6
    HID_KEY_NONE,          // 63: R5_C7
    HID_KEY_NONE,          // 64: R5_C8
    HID_KEY_NONE,          // 65: R5_C9
    HID_KEY_NONE,          // 66: R5_C10
    HID_KEY_NONE,          // 67: R6_C0
    HID_KEY_NONE,          // 68: R6_C1
    HID_KEY_NONE,          // 69: R6_C2
    HID_KEY_NONE,          // 70: R6_C3
    HID_KEY_NONE,          // 71: R6_C4
    HID_KEY_NONE,          // 72: R6_C5
    HID_KEY_NONE,          // 73: R6_C6
    HID_KEY_NONE,          // 74: R6_C7
    HID_KEY_NONE,          // 75: R6_C8
    HID_KEY_NONE,          // 76: R6_C9
    HID_KEY_NONE,          // 77: R6_C10
    HID_KEY_NONE,          // 78: R7_C0
    HID_KEY_NONE,          // 79: R7_C1
    HID_KEY_NONE,          // 80: R7_C2
    HID_KEY_NONE,          // 81: R7_C3
    HID_KEY_NONE,          // 82: R7_C4
    HID_KEY_NONE,          // 83: R7_C5
    HID_KEY_NONE,          // 84: R7_C6
    HID_KEY_NONE,          // 85: R7_C7
    HID_KEY_NONE,          // 86: R7_C8
    HID_KEY_NONE,          // 87: R7_C9
    HID_KEY_NONE,          // 88: R7_C10
    HID_KEY_NONE,          // 89: R0_GND
    HID_KEY_NONE,          // 90: R1_GND
    HID_KEY_NONE,          // 91: R2_GND
    HID_KEY_NONE,          // 92: R3_GND
    HID_KEY_NONE,          // 93: R4_GND
    HID_KEY_NONE,          // 94: R5_GND
    HID_KEY_NONE,          // 95: R6_GND
    HID_KEY_NONE,          // 96: R7_GND
    HID_KEY_NONE,          // 97: GPI1
    HID_KEY_NONE,          // 98: GPI2
    HID_KEY_NONE,          // 99: GPI3
    HID_KEY_NONE,          // 100: GPI4
    HID_KEY_NONE,          // 101: GPI5
    HID_KEY_NONE,          // 102: GPI6
    HID_KEY_NONE,          // 103: GPI7
    HID_KEY_NONE,          // 104: GPI8
    HID_KEY_NONE,          // 105: GPI9
    HID_KEY_NONE,          // 106: GPI10
    HID_KEY_NONE,          // 107: GPI11
    HID_KEY_NONE,          // 108: GPI12
    HID_KEY_NONE,          // 109: GPI13
    HID_KEY_NONE,          // 110: GPI14
    HID_KEY_NONE,          // 111: GPI15
    HID_KEY_NONE,          // 112: GPI16
    HID_KEY_NONE,          // 113: GPI17
    HID_KEY_NONE,          // 114: GPI18
    HID_KEY_NONE,          // 115: GPI19
    HID_KEY_NONE,          // 116: LOGIC_1
    HID_KEY_NONE,          // 117: LOGIC_2
    HID_KEY_NONE,          // 118: UNUSED_0
    HID_KEY_NONE,          // 119: UNUSED_1
    HID_KEY_NONE,          // 120: UNUSED_2
    HID_KEY_NONE,          // 121: UNUSED_3
    HID_KEY_NONE,          // 122: UNUSED_4
    HID_KEY_NONE,          // 123: UNUSED_5
    HID_KEY_NONE,          // 124: UNUSED_6
    HID_KEY_NONE,          // 125: UNUSED_7
    HID_KEY_NONE,          // 126: UNUSED_8
    HID_KEY_NONE,          // 127: UNLOCK_WILDCARD
};

#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))

/**
 * @brief Convert an ADP5589 Keyboard event ID to a TinyUSB HID keycode.
 *
 * See ADP5589 datasheet table 11 for description of EventID values.
 *
 * @param event_id The code returned by the keyboard IC.
 *
 * @return The TinyUSB HID keycode. HID_KEY_NONE if no mapping.
 */
uint8_t KeyboardKeyIDToHIDKeyCode(EventID event_id) {
  return kEventID2KeyCode[static_cast<uint8_t>(event_id)];
}

esp_err_t ResetKeyboard(gpio_num_t reset_pin) {
  esp_err_t err = gpio_set_level(reset_pin, 0);
  if (err != ESP_OK)
    return err;

  vTaskDelay(pdMS_TO_TICKS(30));
  err = gpio_set_level(reset_pin, 1);
  if (err != ESP_OK)
    return err;

  vTaskDelay(pdMS_TO_TICKS(30));
  return ESP_OK;
}

uint8_t GetModifierFlag(uint8_t keycode) {
  switch (keycode) {
    case HID_KEY_SHIFT_LEFT:
      return KEYBOARD_MODIFIER_LEFTSHIFT;
    case HID_KEY_SHIFT_RIGHT:
      return KEYBOARD_MODIFIER_RIGHTSHIFT;
    case HID_KEY_CONTROL_LEFT:
      return KEYBOARD_MODIFIER_LEFTCTRL;
    case HID_KEY_CONTROL_RIGHT:
      return KEYBOARD_MODIFIER_RIGHTCTRL;
    case HID_KEY_ALT_LEFT:
      return KEYBOARD_MODIFIER_LEFTALT;
    case HID_KEY_ALT_RIGHT:
      return KEYBOARD_MODIFIER_RIGHTALT;
    case HID_KEY_GUI_LEFT:
      return KEYBOARD_MODIFIER_LEFTGUI;
    case HID_KEY_GUI_RIGHT:
      return KEYBOARD_MODIFIER_RIGHTGUI;
  }
  return 0x0;
}
}  // namespace

Keyboard::Keyboard(i2c::Master i2c_master)
    : i2c_master_(std::move(i2c_master)), key_states_({false}) {}

Keyboard::~Keyboard() = default;

esp_err_t Keyboard::Reset() {
  ESP_LOGD(TAG, "Resetting keyboard");

  constexpr gpio_config_t config = {
      .pin_bit_mask = (1ULL << kKeyboardResetGPIO),
      .mode = GPIO_MODE_OUTPUT,
      .pull_up_en = GPIO_PULLUP_ENABLE,
      .pull_down_en = GPIO_PULLDOWN_DISABLE,
      .intr_type = GPIO_INTR_DISABLE,
  };
  esp_err_t err = gpio_config(&config);
  if (err != ESP_OK)
    return err;
  err = ResetKeyboard(kKeyboardResetGPIO);
  if (err != ESP_OK)
    return err;

  kbd::adp5589::Register::ID reg_id;
  err = Read(&reg_id);
  if (err != ESP_OK)
    return err;
  key_states_.fill(false);
  ESP_LOGI(TAG, "Keyboard reset, mfr: %u, rev: %u", reg_id.MAN, reg_id.REV);

  return ESP_OK;
}

esp_err_t Keyboard::InitializeKeys(i2c::Operation& op) {
  constexpr kbd::adp5589::Register::PIN_CONFIG_A reg_a = {
      .R7_CONFIG = 0,
      .R6_CONFIG = 0,
      .R5_CONFIG = 0,
      .R4_CONFIG = 0,
      .R3_CONFIG = 0,
      .R2_CONFIG = 0,
      .R1_CONFIG = 1,
      .R0_CONFIG = 1,
  };
  if (!op.RestartReg(static_cast<uint8_t>(RegNum::PIN_CONFIG_A),
                     i2c::Address::Mode::WRITE) ||
      !op.WriteByte(reg_a)) {
    return ESP_FAIL;
  }

  constexpr kbd::adp5589::Register::PIN_CONFIG_B reg_b = {
      .C7_CONFIG = 0,
      .C6_CONFIG = 0,
      .C5_CONFIG = 0,
      .C4_CONFIG = 0,
      .C3_CONFIG = 1,
      .C2_CONFIG = 1,
      .C1_CONFIG = 1,
      .C0_CONFIG = 1,
  };
  if (!op.RestartReg(static_cast<uint8_t>(RegNum::PIN_CONFIG_B),
                     i2c::Address::Mode::WRITE) ||
      !op.WriteByte(reg_b)) {
    return ESP_FAIL;
  }

  constexpr kbd::adp5589::Register::PIN_CONFIG_C reg_c = {
      .Reserved = 0,
      .C10_CONFIG = 0,
      .C9_CONFIG = 0,
      .C8_CONFIG = 0,
  };
  if (!op.RestartReg(static_cast<uint8_t>(RegNum::PIN_CONFIG_C),
                     i2c::Address::Mode::WRITE) ||
      !op.WriteByte(reg_c)) {
    return ESP_FAIL;
  }

  constexpr kbd::adp5589::Register::PIN_CONFIG_D reg_d = {
      .PULL_SELECT = 0,    // 300 kΩ used for row pull-up during key scanning.
      .C4_EXTEND_CFG = 0,  // C4 remains configured as GPIO 13.
      .R4_EXTEND_CFG = 0,  // R4 remains configured as GPIO 5.
      .C6_EXTEND_CFG = 0,  // C6 remains configured as GPIO 15.
      .R3_EXTEND_CFG = 0,  // R3 remains configured as GPIO 4.
      .C9_EXTEND_CFG = 0,  // C9 remains configured as GPIO 18.
      .R0_EXTEND_CFG = 0,  // R0 remains configured as GPIO 1.
  };
  if (!op.RestartReg(static_cast<uint8_t>(RegNum::PIN_CONFIG_D),
                     i2c::Address::Mode::WRITE) ||
      !op.WriteByte(reg_d)) {
    return ESP_FAIL;
  }

  constexpr std::array<RegNum, 5> kRegistersToClear = {
      RegNum::RPULL_CONFIG_A, RegNum::RPULL_CONFIG_B, RegNum::RPULL_CONFIG_C,
      RegNum::RPULL_CONFIG_D, RegNum::RPULL_CONFIG_E,
  };

  for (auto reg : kRegistersToClear) {
    if (!op.RestartReg(static_cast<uint8_t>(reg), i2c::Address::Mode::WRITE) ||
        !op.WriteByte(0x0)) {
      return ESP_FAIL;
    }
  }

  return ESP_OK;
}

esp_err_t Keyboard::InitializeInterrupts(i2c::Operation& op) {
  if (!op.RestartReg(static_cast<uint8_t>(RegNum::INT_EN),
                     i2c::Address::Mode::WRITE)) {
    return ESP_FAIL;
  }
  constexpr kbd::adp5589::Register::INT_EN reg = {
      .Reserved = 0,
      .LOGIC2_IEN = false,
      .LOGIC1_IEN = false,
      .LOCK_IEN = false,
      .OVRFLOW_IEN = true,
      .GPI_IEN = false,
      .EVENT_IEN = true,
  };
  if (!op.WriteByte(reg))
    return ESP_FAIL;
  return ESP_OK;
}

esp_err_t Keyboard::Initialize() {
  esp_err_t err;

  ESP_LOGD(TAG, "Initializing keyboard");

  i2c::Operation op = i2c_master_.CreateWriteOp(
      kSlaveAddress, kI2CAddressSize,
      static_cast<uint8_t>(RegNum::GENERAL_CFG_B), "kbd-init");
  if (!op.ready())
    return ESP_FAIL;

  {
    constexpr kbd::adp5589::Register::GENERAL_CFG_B reg = {
        .OSC_EN = true,  // Enable oscillator.
        .CORE_FREQ = CoreFrequency::kHz500,
        .LCK_TRK_LOGIC = 1,  // 1 = do not track.
        .LCK_TRK_GPI = 1,    // 1 = do not track.
        .Unused = 0,
        .INT_CFG = 1,  // deassert for 50 µs, reassert if interrupt is pending.
        .RST_CFG = 0,  // ADP5589 reset if RST is low.
    };
    if (!op.WriteByte(reg))
      return ESP_FAIL;
  }

  err = InitializeInterrupts(op);
  if (err != ESP_OK)
    return err;
  err = InitializeKeys(op);
  if (err != ESP_OK)
    return err;

  // clang-format off
  constexpr std::array<RegNum, 5> kRegistersToClear = {
      RegNum::LOGIC_1_CFG,
      RegNum::LOGIC_2_CFG,
      RegNum::LOGIC_INT_EVENT_EN,
      RegNum::CLOCK_DIV_CFG,
      RegNum::LOGIC_FF_CFG,
  };
  // clang-format on

  for (auto reg : kRegistersToClear) {
    if (!op.RestartReg(static_cast<uint8_t>(reg), i2c::Address::Mode::WRITE) ||
        !op.WriteByte(0x0)) {
      return ESP_FAIL;
    }
  }

  if (!op.Execute())
    return ESP_FAIL;

  ESP_LOGI(TAG, "Keyboard initialized.");
  return ESP_OK;
}

esp_err_t Keyboard::ReportHIDEvents() {
  uint8_t next_key_idx = 0;
  uint8_t keycodes[6] = {HID_KEY_NONE};
  uint8_t modifier = 0;
  uint8_t num_pressed_keys = 0;  // number of non-modifier keys.

  for (uint8_t keycode = 0; keycode < key_states_.size(); keycode++) {
    if (!key_states_[keycode])
      continue;
    uint8_t modifier_bit = GetModifierFlag(keycode);
    if (modifier_bit) {
      modifier |= modifier_bit;
    } else {
      num_pressed_keys++;
      if (next_key_idx < ARRAY_SIZE(keycodes))
        keycodes[next_key_idx++] = keycode;
    }
  }

  if (num_pressed_keys > ARRAY_SIZE(keycodes)) {
    ESP_LOGW(TAG, "Unable to report all keys. %u pressed, max %u",
             num_pressed_keys, ARRAY_SIZE(keycodes));
  }
  return usb::HID::KeyboardReport(usb::REPORT_ID_KEYBOARD, modifier, keycodes);
}

esp_err_t Keyboard::HandleEvents() {
  esp_err_t err;

  ESP_LOGV(TAG, "Reading keyboard events.");

  kbd::adp5589::Register::INT_STATUS interrupt_status;
  err = Read(&interrupt_status);
  if (err != ESP_OK) {
    ESP_LOGE(TAG, "Failure reading INT_STATUS");
    return err;
  }
  // Write back the INT_STATUS register to clear the INT flags.
  err = WriteByte(RegNum::INT_STATUS, interrupt_status);
  if (err != ESP_OK) {
    ESP_LOGE(TAG, "Failure writing INT_STATUS");
  }
  if (interrupt_status.OVRFLOW_INT) {
    ESP_LOGE(TAG, "Keyboard FIFO overflow.");
    return ESP_FAIL;
  }

  kbd::adp5589::Register::Status status_reg;
  err = Read(&status_reg);
  if (err != ESP_OK) {
    ESP_LOGE(TAG, "Failure reading status register");
    return err;
  }

  if (!status_reg.EC) {
    ESP_LOGV(TAG, "No keyboard events.");
    return ESP_OK;
  }

  constexpr uint8_t kMaxFIFOEntries = 16;
  kbd::adp5589::Register::FIFO fifo[kMaxFIFOEntries];

  for (uint8_t i = 0; i < status_reg.EC; i++) {
    event_number_++;
    err = Read(&fifo[i]);
    if (err != ESP_OK) {
      ESP_LOGE(TAG, "Error reading FIFO entry %u", i);
      return err;
    }
  }

  for (uint8_t i = 0; i < status_reg.EC; i++) {
#ifdef ONLY_LOG_EVENTS
    const char key_state = fifo[i].Event_State ? 'D' : 'U';
    ESP_LOGI(TAG, "keyboard event[%u/%u] (0x%02x) id %s:%c", i + 1,
             status_reg.EC, fifo[i].Event_State,
             adp5589::EventToName(static_cast<EventID>(fifo[i].IDENTIFIER)),
             key_state);
#else
    const uint8_t hid_keycode = KeyboardKeyIDToHIDKeyCode(fifo[i].IDENTIFIER);
    if (hid_keycode < key_states_.size()) {
      const bool key_pressed = fifo[i].Event_State & 0b10000000;
      key_states_[hid_keycode] = key_pressed;
    }
#endif
  }

  ESP_LOGV(TAG, "    Done reading keyboard.");
  return ReportHIDEvents();
}

esp_err_t Keyboard::Read(kbd::adp5589::Register::Status* reg) {
  uint8_t b;
  esp_err_t err = ReadByte(RegNum::Status, &b);
  if (err != ESP_OK)
    return err;

  // clang-format off
  reg->LOGIC2_STAT = b & 0b10000000 ? 1 : 0;
  reg->LOGIC1_STAT = b & 0b01000000 ? 1 : 0;
  reg->LOCK_STAT   = b & 0b00100000 ? 1 : 0;
  reg->EC          = b & 0b00011111;
  // clang-format on

  return ESP_OK;
}

esp_err_t Keyboard::Read(kbd::adp5589::Register::INT_STATUS* reg) {
  uint8_t b;
  esp_err_t err = ReadByte(RegNum::INT_STATUS, &b);
  if (err != ESP_OK)
    return err;

  // clang-format off
  reg->LOGIC2_INT  = b & 0b00100000 ? 1 : 0;
  reg->LOGIC1_INT  = b & 0b00010000 ? 1 : 0;
  reg->LOCK_INT    = b & 0b00001000 ? 1 : 0;
  reg->OVRFLOW_INT = b & 0b00000100 ? 1 : 0;
  reg->GPI_INT     = b & 0b00000010 ? 1 : 0;
  reg->EVENT_INT   = b & 0b00000001;
  // clang-format on

  return ESP_OK;
}

esp_err_t Keyboard::Read(kbd::adp5589::Register::FIFO* reg) {
  uint8_t b;
  esp_err_t err = ReadByte(RegNum::FIFO_1, &b);
  if (err != ESP_OK)
    return err;

  reg->Event_State = b & 0b10000000 ? 1 : 0;
  reg->IDENTIFIER = static_cast<EventID>(b & 0b01111111);

  return ESP_OK;
}

esp_err_t Keyboard::Read(kbd::adp5589::Register::ID* reg) {
  uint8_t b;
  esp_err_t err = ReadByte(RegNum::ID, &b);
  if (err != ESP_OK)
    return err;

  reg->MAN = b & 0xF0 >> 4;
  reg->REV = b & 0x0F;

  return ESP_OK;
}

esp_err_t Keyboard::ReadByte(RegNum reg, uint8_t* value) {
  return i2c_master_.ReadRegister(kSlaveAddress, kI2CAddressSize,
                                  static_cast<uint8_t>(reg), value)
             ? ESP_OK
             : ESP_FAIL;
}

esp_err_t Keyboard::WriteByte(RegNum reg, uint8_t value) {
  return i2c_master_.WriteRegister(kSlaveAddress, kI2CAddressSize,
                                   static_cast<uint8_t>(reg), value)
             ? ESP_OK
             : ESP_FAIL;
}
